using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Timers;
using System.Threading;
using CsvHelper;
using CsvHelper.Configuration.Attributes;
using System.Linq;

using rpc_201ef99a_7fa0_444c_9399_19ba84f12a1a_1_0;

namespace RPCExploit
{

    public class DataRecord
    {
        [Name("Time of Day")]
        public string TimeOfDay { get; set; }

        [Name("Process Name")]
        public string ProcessName { get; set; }

        public string PID { get; set; }
        public string Operation { get; set; }
        public string Path { get; set; }
        public string Result { get; set; }
        public string Detail { get; set; }

        //[Name("Image Path")]
        //public string ImagePath { get; set; }

        public static IEnumerable<DataRecord> ParseDataRecords(Stream file)
        {
            using (var sr = new StreamReader(file))
            using (var csv = new CsvReader(sr))
            {
                foreach (var record in csv.GetRecords<DataRecord>())
                {
                    yield return record;
                }
            }
        }
    }

    class Program
    {

        static int DURATION = 10;
        //static string FILTER = "ProcessName,is,Explorer.exe,Include";
        static string FILTER = "Integrity,is,medium,Exclude;Detail,contains,Impersonating: desktop,Exclude"; // because my group is like desktop-asdf123 and we want to see SYSTEM results

        static bool timerDone = false;
        static System.Timers.Timer aTimer = new System.Timers.Timer();
        static string fileName;


        public static void fileModifyCheck(IEnumerable<DataRecord> records) {

            DataRecord[] raw_records = records.ToArray();
            for (int i = 0; i < raw_records.Length; i++)
            {
                if (raw_records[i].Operation == "CreateFile" && raw_records[i].Result == "NAME NOT FOUND")
                {

                    bool fileMoveWriteCheck = false;
                    bool deleteCheck = false;
                    int setRenameInformationFileIndex = -1;

                    // lets scan for up to 10 events preceding NAME NOT FOUND for the fileMoveCheck
                    for (int j = i - 10; j < i; j++)
                    {
                        // scan for SetRenameInformationFile (File being moved away)
                        if (raw_records[j].Path == raw_records[i].Path && raw_records[j].Operation == "SetRenameInformationFile" && raw_records[j].Result == "SUCCESS")
                        {

                            // check if we have write permission for the folder
                            string path = Path.GetDirectoryName(raw_records[j].Path);
                            try
                            {
                                System.Security.AccessControl.DirectorySecurity ds = Directory.GetAccessControl(path);
                                fileMoveWriteCheck = true;

                                setRenameInformationFileIndex = j;


                            }
                            catch (UnauthorizedAccessException)
                            {
                                // we do not have write access to this folder
                                continue;
                            }

                        }
                    }

                    // lets scan for up to 10 events preceding NAME NOT FOUND for the deleteCheck
                    for (int j = i - 10; j < i; j++)
                    {
                        if (raw_records[j].Path == raw_records[i].Path && raw_records[j].Detail.Contains("Delete"))
                        {
                            deleteCheck = true;
                        }
                    }

                    if (fileMoveWriteCheck && deleteCheck)
                    {
                        Console.WriteLine("Potential file modify vulnerable pattern found:");
                        Console.WriteLine("Files (pmf + csv): " + fileName);
                        Console.WriteLine("Target: " + raw_records[setRenameInformationFileIndex].Path);
                        Console.WriteLine("Time: " + raw_records[setRenameInformationFileIndex].TimeOfDay);
                    }
                }


            }

        }

        private static void OnTimedEvent(object source, ElapsedEventArgs e)
        {
            if (!timerDone)
            {
                timerDone = true;
                aTimer.Enabled = false;

                Console.WriteLine("Procmon output generated. Parsing results...");

                TextReader textReader = new StreamReader(@"C:\Users\Karp\source\repos\RPCExploit\RPCExploit\bin\Debug\" + fileName);
                var csvReader = new CsvReader(textReader);
                IEnumerable<DataRecord> records = csvReader.GetRecords<DataRecord>();

                /*foreach(var record in records)
                {
                    Console.WriteLine(record.PID);
                    Console.WriteLine(record.Path);
                    Console.WriteLine(record.Operation);
                    Console.WriteLine(record.ProcessName);
                    Console.WriteLine(record.Result);
                    Console.WriteLine(record.Detail);
                    Console.WriteLine(record.TimeOfDay);
                    Console.WriteLine();
                }*/

                // Now we implement the logic for finding a particular LPE indicator
                // NOTE: function untested. need to go through msiexec /fa example to produce the desired procmon output. after we get that we can test whether fileModifyCheck matches the pattern as expected. 
                fileModifyCheck(records);


            }   
            
        }

        static void Main(string[] args)
        {

            var ps = @"C:\Users\Karp\source\repos\RPCExploit\RPCExploit\test.ps1";
            var processInfo2 = Process.Start(@"powershell.exe", " -ExecutionPolicy Bypass procmon.exe /Terminate"); // just in case it's already running
            Thread.Sleep(1000);

            
            aTimer.Elapsed += new ElapsedEventHandler(OnTimedEvent);
            aTimer.Interval = (DURATION + 10) * 1000; // lets add a 10 second buffer for while it saves the results to disk just in case
            aTimer.Enabled = true;


            // generate our noise for procmon
            // in this example we're calling a random function with random params on an RPC server
            Client client = new Client();
            client.Connect();
            client.SvchostPushServiceGlobals_5(-1);

            Guid id = Guid.NewGuid();
            fileName = id.ToString();

            var processInfo = Process.Start(@"powershell.exe", " -ExecutionPolicy Bypass -File " + ps + " -Filter " + FILTER + " -Duration " + DURATION + " -CsvName " + fileName);

            Console.WriteLine("Press \'q\' to quit the sample.");
            while (Console.Read() != 'q') ;





        }
    }
}
