using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Timers;
using System.Threading;
using CsvHelper;
using CsvHelper.Configuration.Attributes;
using System.Linq;

using rpc_201ef99a_7fa0_444c_9399_19ba84f12a1a_1_0;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Runtime.InteropServices;

namespace RPCExploit
{

    public class Procmon
    {
        [Name("Time of Day")]
        public string TimeOfDay { get; set; }

        [Name("Process Name")]
        public string ProcessName { get; set; }

        public string PID { get; set; }
        public string Operation { get; set; }
        public string Path { get; set; }
        public string Result { get; set; }
        public string Detail { get; set; }

        //[Name("Image Path")]
        //public string ImagePath { get; set; }

        public static IEnumerable<Procmon> ParseDataRecords(Stream file)
        {
            using (var sr = new StreamReader(file))
            using (var csv = new CsvReader(sr))
            {
                foreach (var record in csv.GetRecords<Procmon>())
                {
                    yield return record;
                }
            }
        }
    }

    class Program
    {
        // Modulate duration with save delay to avoid FileNotFoundException
        static int DURATION = 30;
        static string ps = @"..\..\test.ps1";

        static string FILTER = "Integrity,is,medium,Exclude;Detail,contains,\"Impersonating: desktop\",Exclude;ProcessName,is,\"Procmon.exe\",Exclude"; // because my group is like desktop-asdf123 and we want to see SYSTEM results

        static System.Timers.Timer aTimer = new System.Timers.Timer();
        static string fileName;

        public static void execCodeControlCheck(Procmon[] raw_records)
        {
            for (int i = 0; i < raw_records.Length; i++)
            {
                if (raw_records[i].Operation == "CreateFile" && (raw_records[i].Result == "NO SUCH FILE" || raw_records[i].Result == "NAME NOT FOUND") && raw_records[i].Path.EndsWith(".dll") || raw_records[i].Path.EndsWith(".exe"))
                {

                    try
                    {
                        string NtAccountName = @"BUILTIN\Users";

                        string dir = new FileInfo(raw_records[i].Path).Directory.FullName;
                        DirectoryInfo di = new DirectoryInfo(dir);
                        DirectorySecurity acl = di.GetAccessControl(AccessControlSections.All);
                        AuthorizationRuleCollection rules = acl.GetAccessRules(true, true, typeof(NTAccount));

                        //Go through the rules returned from the DirectorySecurity
                        foreach (AuthorizationRule rule in rules)
                        {
                            //If we find one that matches the identity we are looking for
                            if (rule.IdentityReference.Value.Equals(NtAccountName, StringComparison.CurrentCultureIgnoreCase))
                            {
                                var filesystemAccessRule = (FileSystemAccessRule)rule;

                                //Cast to a FileSystemAccessRule to check for access rights
                                if ((filesystemAccessRule.FileSystemRights & FileSystemRights.WriteData) > 0 && filesystemAccessRule.AccessControlType != AccessControlType.Deny)
                                {
                                    Console.WriteLine("Executable code control identified:");
                                    Console.WriteLine("Files (pmf + csv): " + fileName);
                                    Console.WriteLine("PID: " + raw_records[i].PID);
                                    Console.WriteLine("Time: " + raw_records[i].TimeOfDay);
                                    Console.WriteLine("Requested file (no such file exists): " + raw_records[i].Path);
                                    Console.WriteLine();
                                }
                                else
                                {
                                    //Console.WriteLine(string.Format("{0} does not have write access to {1}", NtAccountName, path));
                                    continue;
                                }
                            }
                        }

                    }
                    catch (Exception)
                    {
                        // problem
                        continue;
                    }
                    
                }
            }



        }

        public static void arbFileWriteCheck(Procmon[] raw_records)
        {

            // perform check for CreateFile
            for (int i = 0; i < raw_records.Length; i++)
            {                                                                                  // and it's a file
                if (raw_records[i].Operation == "CreateFile" && raw_records[i].Result == "SUCCESS" && raw_records[i].Path.Contains("."))
                {

                    try
                    {

                        AuthorizationRuleCollection arcFile = File.GetAccessControl(raw_records[i].Path).GetAccessRules(true, true, typeof(System.Security.Principal.SecurityIdentifier));
                        foreach (AuthorizationRule arFile in arcFile)
                        {
                            if (arFile.IdentityReference.Value == @"S-1-5-32-545") // BUILTIN\Users
                            {
                                FileSystemAccessRule fasrFile = (FileSystemAccessRule)arFile;
                                if (fasrFile.AccessControlType == AccessControlType.Allow && fasrFile.FileSystemRights.HasFlag(FileSystemRights.FullControl))
                                {
                                    Console.WriteLine("Arbitrary file write identified:");
                                    Console.WriteLine("Files (pmf + csv): " + fileName);
                                    Console.WriteLine("PID: " + raw_records[i].PID);
                                    Console.WriteLine("Time: " + raw_records[i].TimeOfDay);
                                    Console.WriteLine("There was a high/system integrity CreateFile to a path that you have full control of: " + raw_records[i].Path);
                                    Console.WriteLine();
                                }
                            }
                        }

                    } catch(Exception e)
                    {
                        // problem
                        continue;
                    }
                    
                }



                
                /*
                // perform check for dll hijacking                                                                                                                                                                                  THIS IS A PATCH
                if (pid!=0 && Int32.Parse(raw_records[i].PID) == pid && raw_records[i].Operation == "CreateFile" && raw_records[i].Result == "NAME NOT FOUND" && raw_records[i].Path.ToLower().EndsWith(".dll") && raw_records[i].Path.Contains("Program"))
                {
                    for (int j = i + 1; j < raw_records.Length && j < i + 50; j++) // we'll only scan within 50 to save resources
                    {
                        try
                        {
                            string jPath = new FileInfo(raw_records[j].Path).Directory.FullName;
                            string jFilename = Path.GetFileName(raw_records[j].Path);

                            string iPath = new FileInfo(raw_records[i].Path).Directory.FullName;
                            string iFilename = Path.GetFileName(raw_records[i].Path);

                            if (jFilename.ToLower() == iFilename.ToLower() && raw_records[j].Operation == "Load Image")
                            {
                                
                                hijackCheck = true;
                                lastHijackEvent = raw_records[i];
                            }
                        }
                        catch (Exception)
                        {
                            //problem
                            continue;
                        }


                    }
                }  */              

                // Additionally, if there's ever a Load Image to a directory BUILTIN\Users has full control of then that's an LPE
                if (raw_records[i].Operation == "Load Image")
                {
                    try
                    {

                        AuthorizationRuleCollection arcFile = File.GetAccessControl(raw_records[i].Path).GetAccessRules(true, true, typeof(System.Security.Principal.SecurityIdentifier));
                        foreach (AuthorizationRule arFile in arcFile)
                        {
                            if (arFile.IdentityReference.Value == @"S-1-5-32-545") // BUILTIN\Users
                            {
                                FileSystemAccessRule fasrFile = (FileSystemAccessRule)arFile;
                                if (fasrFile.AccessControlType == AccessControlType.Allow && fasrFile.FileSystemRights.HasFlag(FileSystemRights.FullControl))
                                {
                                    Console.WriteLine("Load image to a path you have full control of:");
                                    Console.WriteLine("Files (pmf + csv): " + fileName);
                                    Console.WriteLine("PID: " + raw_records[i].PID);
                                    Console.WriteLine("Time: " + raw_records[i].TimeOfDay);
                                    Console.WriteLine("Loaded DLL: " + raw_records[i].Path);
                                    Console.WriteLine();
                                }
                            }
                        }

                    }
                    catch (Exception)
                    {
                        //problem
                        continue;
                    }

                   
                }
            }

           
        }


        public static void fileModifyCheck(Procmon[] raw_records)
        {
            
            for (int i = 0; i < raw_records.Length; i++)
            {
                if (raw_records[i].Operation == "CreateFile" && raw_records[i].Result == "NAME NOT FOUND")
                {

                    bool fileMoveWriteCheck = false;
                    bool deleteCheck = false;
                    int setRenameInformationFileIndex = -1;

                    // lets scan for up to 200 events preceding NAME NOT FOUND to perform the fileMoveCheck
                    for (int j = i - 200; j < i; j++)
                    {
                        // scan for SetRenameInformationFile (File being moved away)
                        if (j > 0 && (raw_records[j].Path == raw_records[i].Path && raw_records[j].Operation == "SetRenameInformationFile" && raw_records[j].Result == "SUCCESS"))
                        {

                            // check if we have write permission for the folder
                            string path = Path.GetDirectoryName(raw_records[j].Path);
                            try
                            {

                                string NtAccountName = @"BUILTIN\Users";

                                DirectoryInfo di = new DirectoryInfo(path);
                                DirectorySecurity acl = di.GetAccessControl(AccessControlSections.All);
                                AuthorizationRuleCollection rules = acl.GetAccessRules(true, true, typeof(NTAccount));

                                //Go through the rules returned from the DirectorySecurity
                                foreach (AuthorizationRule rule in rules)
                                {
                                    //If we find one that matches the identity we are looking for
                                    if (rule.IdentityReference.Value.Equals(NtAccountName, StringComparison.CurrentCultureIgnoreCase))
                                    {
                                        var filesystemAccessRule = (FileSystemAccessRule)rule;

                                        //Cast to a FileSystemAccessRule to check for access rights
                                        if ((filesystemAccessRule.FileSystemRights & FileSystemRights.WriteData) > 0 && filesystemAccessRule.AccessControlType != AccessControlType.Deny)
                                        {
                                            //Console.WriteLine(string.Format("{0} has write access to {1}", NtAccountName, path));
                                            fileMoveWriteCheck = true;
                                            setRenameInformationFileIndex = j;
                                        }
                                        else
                                        {
                                            //Console.WriteLine(string.Format("{0} does not have write access to {1}", NtAccountName, path));
                                            continue;
                                        }
                                    }
                                }


                            }
                            catch (Exception e)
                            {
                                // problem
                                continue;
                            }

                        }
                    }

                    // lets scan for up to 50 events preceding NAME NOT FOUND for the deleteCheck
                    for (int j = i - 50; j < i; j++)
                    {
                        if (j > 0 && raw_records[j].Path == raw_records[i].Path && raw_records[j].Detail.Contains("Delete"))
                        {
                            deleteCheck = true;
                        }
                    }

                    if (fileMoveWriteCheck && deleteCheck)
                    {
                        Console.WriteLine("Timining window identified for potential file modify:");
                        Console.WriteLine("Files (pmf + csv): " + fileName);
                        Console.WriteLine("PID: " + raw_records[setRenameInformationFileIndex].PID);
                        Console.WriteLine("Target: " + raw_records[setRenameInformationFileIndex].Path);
                        Console.WriteLine("Time: " + raw_records[setRenameInformationFileIndex].TimeOfDay);
                        Console.WriteLine();
                    }
                }


            }

            
        }


        private static void analyze()
        {
            Console.WriteLine("Procmon output generated. Parsing results for " + fileName);
            Console.WriteLine();

            TextReader textReader = new StreamReader(fileName + ".csv");
            var csvReader = new CsvReader(textReader);
            IEnumerable<Procmon> records = csvReader.GetRecords<Procmon>();
            Procmon[] raw_records = records.ToArray();

            // Now we implement the logic for finding a particular LPE indicator

            var threads = new Thread[] {
                new Thread(() =>
                {
                    fileModifyCheck(raw_records);
                }),
                new Thread(() =>
                {
                    execCodeControlCheck(raw_records);
                }),
                new Thread(() =>
                {
                    arbFileWriteCheck(raw_records);
                })
                };

            foreach (var t in threads)
                t.Start();

            // block the initial thread until the new threads are finished
            foreach (var t in threads)
                t.Join();

            Console.WriteLine("Analysis complete for " + fileName);
            Console.WriteLine();
        }

        static void waitForProcmon()
        {

            while (!File.Exists(fileName + ".csv"))
            {
                Thread.Sleep(1000);
            }

            bool open = false;
            while (!open)
            {
                try
                {
                    using (Stream stream = new FileStream(fileName + ".csv", FileMode.Open))
                    {
                        open = true;
                    }
                }
                catch
                {
                    // file locked by procmon, no bueno
                    continue;
                }
            }
            
        }

        static void record()
        {
            Guid id = Guid.NewGuid();
            fileName = id.ToString();
            Process.Start(@"powershell.exe", " -ExecutionPolicy Bypass -File " + ps + " -Filter " + FILTER + " -Duration " + DURATION + " -CsvName " + fileName);
        }

        static void prepareProcmon()
        {
            var processInfo2 = Process.Start(@"procmon.exe", " /Terminate"); // just in case it's already running
            Thread.Sleep(1000);
        }

        // TODO
        // https://stackoverflow.com/questions/5152346/get-only-methods-with-specific-signature-out-of-type-getmethods
        // 1) Get visual studio to ignore duplicate methods/fields and add all .cs files into the project
        // 2) Specify invocation en-masse based on parameter definitions
        //    2.1) Build list of common vulnerable parameter definitions and their respective invocations (e.g. string => "A" * 9001)
        // 3) Use reflection to enumerate every method and invoke all


        // generate our noise for procmon
        // in this example we're calling a random function with random params on an RPC server
        //Client client = new Client();
        //client.Connect();
        //client.SvchostPushServiceGlobals_5(-1);

        static void Main(string[] args)
        {
            // Below is my example implementation of n iterations

            DirectoryInfo d = new DirectoryInfo(@"C:\Windows\Installer");
            FileInfo[] Files = d.GetFiles("*.msi"); //Getting msi files
            foreach (FileInfo file in Files)
            {

                prepareProcmon();

                Process.Start("msiexec.exe", @" /fa " + file.FullName); // run whatever you want
                Process.Start("cmd.exe", @" /c sc restart goverlanagent"); // run whatever you want
                Console.WriteLine("Running msiexec.exe /fa " + file.FullName);

                record(); // record the behavior of your activity using procmon

                waitForProcmon(); // until DURATION

                analyze(); // analyze for vulnerable behavior
            }


            // Below is an example implementation without looping

            /*
            prepareProcmon();
            Process.Start("cmd.exe", @" /c sc restart goverlanagent"); // run whatever you want
            record(); // record the behavior of your activity using procmon
            waitForProcmon(); // until DURATION
            analyze(); // analyze for vulnerable behavior
            */

            Console.WriteLine("Press \'q\' to quit.");
            while (Console.Read() != 'q') ;

        }
        
    }
}
