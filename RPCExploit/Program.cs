using System;
using System.Collections.Generic;
using System.IO;
using System.Diagnostics;
using System.Timers;
using System.Threading;
using CsvHelper;
using CsvHelper.Configuration.Attributes;
using System.Linq;

using rpc_201ef99a_7fa0_444c_9399_19ba84f12a1a_1_0;

namespace RPCExploit
{

    public class Procmon
    {
        [Name("Time of Day")]
        public string TimeOfDay { get; set; }

        [Name("Process Name")]
        public string ProcessName { get; set; }

        public string PID { get; set; }
        public string Operation { get; set; }
        public string Path { get; set; }
        public string Result { get; set; }
        public string Detail { get; set; }

        //[Name("Image Path")]
        //public string ImagePath { get; set; }

        public static IEnumerable<Procmon> ParseDataRecords(Stream file)
        {
            using (var sr = new StreamReader(file))
            using (var csv = new CsvReader(sr))
            {
                foreach (var record in csv.GetRecords<Procmon>())
                {
                    yield return record;
                }
            }
        }
    }

    class Program
    {

        static int DURATION = 30;
        //static string FILTER = "ProcessName,is,Explorer.exe,Include";
        static string FILTER = "Integrity,is,medium,Exclude;Detail,contains,\"Impersonating: desktop\",Exclude"; // because my group is like desktop-asdf123 and we want to see SYSTEM results

        static bool timerDone = false;
        static System.Timers.Timer aTimer = new System.Timers.Timer();
        static string fileName;


        public static void fileModifyCheck(IEnumerable<Procmon> records) {

            Procmon[] raw_records = records.ToArray();
            for (int i = 0; i < raw_records.Length; i++)
            {
                if (raw_records[i].Operation == "CreateFile" && raw_records[i].Result == "NAME NOT FOUND")
                {

                    bool fileMoveWriteCheck = false;
                    bool deleteCheck = false;
                    int setRenameInformationFileIndex = -1;

                    // lets scan for up to 200 events preceding NAME NOT FOUND to perform the fileMoveCheck
                    for (int j = i - 200; j < i; j++)
                    {
                        // scan for SetRenameInformationFile (File being moved away)
                        if (j > 0 && (raw_records[j].Path == raw_records[i].Path && raw_records[j].Operation == "SetRenameInformationFile" && raw_records[j].Result == "SUCCESS"))
                        {

                            // check if we have write permission for the folder
                            string path = Path.GetDirectoryName(raw_records[j].Path);
                            try
                            {
                                // NOTE: This is likely not how I want to implement this check. I need to check against the "Users" group, and _this_ is probably running in Administrator context (needed by procmon)
                                System.Security.AccessControl.DirectorySecurity ds = Directory.GetAccessControl(path);
                                fileMoveWriteCheck = true;

                                setRenameInformationFileIndex = j;


                            }
                            catch (UnauthorizedAccessException)
                            {
                                // we do not have write access to this folder
                                continue;
                            }

                        }
                    }

                    // lets scan for up to 50 events preceding NAME NOT FOUND for the deleteCheck
                    for (int j = i - 50; j < i; j++)
                    {
                        if (raw_records[j].Path == raw_records[i].Path && raw_records[j].Detail.Contains("Delete"))
                        {
                            deleteCheck = true;
                        }
                    }

                    if (fileMoveWriteCheck && deleteCheck)
                    {
                        Console.WriteLine("Timining window identified for potential file modify:");
                        Console.WriteLine("Files (pmf + csv): " + fileName);
                        Console.WriteLine("PID: " + raw_records[setRenameInformationFileIndex].PID);
                        Console.WriteLine("Target: " + raw_records[setRenameInformationFileIndex].Path);
                        Console.WriteLine("Time: " + raw_records[setRenameInformationFileIndex].TimeOfDay);
                        Console.WriteLine();
                    }
                }


            }

        }

        private static void OnTimedEvent(object source, ElapsedEventArgs e)
        {
            if (!timerDone)
            {
                timerDone = true;
                aTimer.Enabled = false;

                Console.WriteLine("Procmon output generated. Parsing results...");

                TextReader textReader = new StreamReader(@"C:\Users\Karp\source\repos\RPCExploit\RPCExploit\bin\Debug\" + fileName + ".csv");
                //TextReader textReader = new StreamReader("fileModifyExample.CSV"); // DEBUG
                var csvReader = new CsvReader(textReader);
                IEnumerable<Procmon> records = csvReader.GetRecords<Procmon>();

                /*foreach(var record in records)
                {
                    Console.WriteLine(record.PID);
                    Console.WriteLine(record.Path);
                    Console.WriteLine(record.Operation);
                    Console.WriteLine(record.ProcessName);
                    Console.WriteLine(record.Result);
                    Console.WriteLine(record.Detail);
                    Console.WriteLine(record.TimeOfDay);
                    Console.WriteLine();
                }*/

                // Now we implement the logic for finding a particular LPE indicator
                // NOTE: function untested. need to go through msiexec /fa example to produce the desired procmon output. after we get that we can test whether fileModifyCheck matches the pattern as expected. 
                fileModifyCheck(records);
                Console.WriteLine("Done");

            }   
            
        }

        static void Main(string[] args)
        {

            var ps = @"C:\Users\Karp\source\repos\RPCExploit\RPCExploit\test.ps1";
            var processInfo2 = Process.Start(@"procmon.exe", " /Terminate"); // just in case it's already running
            Thread.Sleep(1000);

            
            aTimer.Elapsed += new ElapsedEventHandler(OnTimedEvent);
            aTimer.Interval = (DURATION + 40) * 1000; // lets add a 20 second buffer for while it saves the results to disk just in case
            //aTimer.Interval = 1;
            aTimer.Enabled = true;


            // TODO
            // https://stackoverflow.com/questions/5152346/get-only-methods-with-specific-signature-out-of-type-getmethods
            // 1) Get visual studio to ignore duplicate methods/fields and add all .cs files into the project
            // 2) Specify invocation en-masse based on parameter definitions
            //    2.1) Build list of common vulnerable parameter definitions and their respective invocations (e.g. string => "A" * 9001)
            // 3) Use reflection to enumerate every method and invoke all


            // generate our noise for procmon
            // in this example we're calling a random function with random params on an RPC server
            //Client client = new Client();
            //client.Connect();
            //client.SvchostPushServiceGlobals_5(-1);

            Process.Start("msiexec.exe", @" /fa C:\Windows\Installer\14164.msi"); // My only msi in that folder authored by VMWare

            Guid id = Guid.NewGuid();
            fileName = id.ToString();

            
            var processInfo = Process.Start(@"powershell.exe", " -ExecutionPolicy Bypass -File " + ps + " -Filter " + FILTER + " -Duration " + DURATION + " -CsvName " + fileName);
            


            Console.WriteLine("Press \'q\' to quit the sample.");
            while (Console.Read() != 'q') ;





        }
    }
}
